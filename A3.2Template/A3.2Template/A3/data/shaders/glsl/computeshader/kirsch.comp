// Rommel Sim Zhen Peng
// Assignment 3

#version 450

// Define constants for tile and block dimensions
#define TILE_WIDTH 16
#define O_TILE_WIDTH 14
#define MASK_WIDTH 3
#define BLOCK_WIDTH (O_TILE_WIDTH + MASK_WIDTH - 1)
#define SM_WIDTH (TILE_WIDTH + MASK_WIDTH - 1)
#define WIDTH_SQUARE (TILE_WIDTH * TILE_WIDTH)
#define NUM_LOADS int(float(SM_WIDTH * SM_WIDTH) / float(WIDTH_SQUARE) + 1.0)
#define DIVIDE_WIDTH (TILE_WIDTH + 2)

layout (local_size_x = TILE_WIDTH, local_size_y = TILE_WIDTH, local_size_z = 1) in;

// Bind input and output images
layout (binding = 0, rgba8) uniform readonly image2D inputImage;
layout (binding = 1, rgba8) uniform image2D outputImage;

// Kirsch Kernel Array
const float kirsch[8][3][3] = {
        {
         {5, 5, 5},
         {-3, 0, -3},           /*rotation 1 */
         {-3, -3, -3}
         },
        {
         {5, 5, -3},
         {5, 0, -3},            /*rotation 2 */
         {-3, -3, -3}
         },
        {
         {5, -3, -3},
         {5, 0, -3},            /*rotation 3 */
         {5, -3, -3}
         },
        {
         {-3, -3, -3},
         {5, 0, -3},            /*rotation 4 */
         {5, 5, -3}
         },
        {
         {-3, -3, -3},
         {-3, 0, -3},           /*rotation 5 */
         {5, 5, 5}
         },
        {
         {-3, -3, -3},
         {-3, 0, 5},            /*rotation 6 */
         {-3, 5, 5}
         },
        {
         {-3, -3, 5},
         {-3, 0, 5},            /*rotation 7 */
         {-3, -3, 5}
         },
        {
         {-3, 5, 5},
         {-3, 0, 5},            /*rotation 8 */
         {-3, -3, -3}
         }
    };

// Shared Memory
shared vec3 sData[SM_WIDTH][SM_WIDTH];

void main() {

    // Compute thread indices within workgroup and overall grid
    int tx = int(gl_LocalInvocationID.x);
    int ty = int(gl_LocalInvocationID.y);
    int bx = int(gl_WorkGroupID.x);
    int by = int(gl_WorkGroupID.y);

    // Get size of input image
    ivec2 imgSize = imageSize(inputImage);
    int width = imgSize.x;
    int height = imgSize.y;

    // Load a tile of the input image into shared memory
    for (int i = 0; i < NUM_LOADS; ++i) {
        int A = ty * TILE_WIDTH + tx + (i * WIDTH_SQUARE);
        int sy = A / DIVIDE_WIDTH;
        int sx = A % DIVIDE_WIDTH;

        int iY = (by * TILE_WIDTH) + sy - 1;
        int iX = (bx * TILE_WIDTH) + sx - 1;

        // Check boundaries and load pixel data into shared memory
        if (sy < SM_WIDTH && sx < SM_WIDTH) {
            if (iY >= 0 && iY < height && iX >= 0 && iX < width) {
                vec4 pixel = imageLoad(inputImage, ivec2(iX, iY));
                sData[sy][sx] = pixel.rgb; // Store RGB components directly
            } else {
                sData[sy][sx] = vec3(0.0); // Default to black for out-of-bounds
            }
        }
    }

    // Synchronize to ensure all threads have loaded their portion of the image
    barrier();

    // Calculate output pixel coordinates
    int row_o = by * TILE_WIDTH + ty;
    int col_o = bx * TILE_WIDTH + tx;

    // Perform edge detection only if within image bounds
    if (row_o < height && col_o < width) {
        vec3 max_sum = vec3(0.0);

        // Apply the Kirsch filters
        for (int m = 0; m < 8; ++m) {
            vec3 sum = vec3(0.0);

            // Convolution
            for (int i = 0; i < MASK_WIDTH; ++i) {
                for (int j = 0; j < MASK_WIDTH; ++j) {
                    float maskValue = kirsch[m][i][j];
                    sum += sData[i + ty][j + tx] * maskValue;
                }
            }

            // Keep the maximum response across all orientations
            max_sum = max(sum, max_sum); // Component-wise max
        }

        // Normalize and clamp the sum to the [0.0, 1.0] range before storing
        vec4 resultColor = vec4(clamp(max_sum / 8.0, 0.0, 1.0), 1.0);
        imageStore(outputImage, ivec2(col_o, row_o), resultColor);
    }

    // Synchronize to ensure all threads have completed writing
    barrier();
}
